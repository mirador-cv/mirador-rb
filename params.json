{"name":"Mirador-rb","tagline":"Ruby client for Mirador (http://mirador.im) API","body":"# Mirador\r\n\r\nA simple Ruby client for the [mirador](http://mirador.im) Image moderation API.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'mirador'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install mirador\r\n\r\n## Usage\r\n\r\nTo get started, you need an API key, available from [mirador.im/join](http://mirador.im/). If you have problems with the API or this client, please contact support@mirador.im.\r\n\r\n## Mirador::Result and Mirador::ResultList\r\n\r\nAll multiple-request methods (e.g., classify_files), return a [Mirador::ResultList](#resultlist), which is effectively a list of Mirador::Result objects; single-request methods (e.g., classify_url) return a [Mirador::Result](#result) object.\r\n\r\n## Classifying Files & Buffers\r\n\r\nYou can classify 4 types of files/file-objects:\r\n\r\n* file objects (e.g., `x` where `x = File.open('myfile.jpg')`); [classify_files](#classify_files)\r\n* filenames `myfile.jpg` [classify_files](#classify_files)\r\n* buffers `buffer = File.read('myfile.jpg')` [classify_buffers](#classify_buffers)\r\n* base64-encoded buffers (e.g., from a data URI) [classify_encoded_strings](#classify_encoded_strings)\r\n\r\nThe methods for file-based classification are as follows:\r\n\r\n\r\n### <a name=\"classify_files\"></a> Mirador::Client#classify_files\r\n\r\n```ruby\r\nrequire 'mirador'\r\nmc = Mirador::Client.new('your_api_key')\r\n\r\nresults = mc.classify_files('test.jpg', 'picture.jpg')\r\n\r\nassert results['test.jpg']\r\nassert_equal results.length, 2\r\n\r\nresults.each do |res|\r\n  puts \"#{ res.id }, #{ res.value }\"\r\nend\r\n\r\nresults.each do |id, res|\r\n  puts \"#{ id }, #{ res.value }\"\r\nend\r\n\r\n```\r\n\r\nYou can also specify an id to be used:\r\n\r\n```ruby\r\nrequire 'mirador'\r\nmc = Mirador::Client.new 'your_api_key'\r\n\r\n# first method: use ids as keys\r\nresults = mc.classify_files(nsfw: 'nsfw.jpg', sfw: 'sfw.jpg')\r\n\r\nassert results[:nsfw]\r\nassert results[:sfw]\r\n\r\n# second method: pass an array of { id:, data: } hashes\r\nresults = mc.classify_files([{ id: :nsfw, data: 'nsfw.jpg'}, { id: :sfw, data: 'sfw.jpg' }])\r\n\r\nassert results[:nsfw]\r\nassert results[:sfw]\r\n```\r\n\r\nFile can be either a filename or a file object; e.g., the following is also valid:\r\n\r\n```ruby\r\nresults = mc.classify_files(nsfw: File.open('nsfw.jpg'))\r\n```\r\n\r\n### <a name='classify_file'></a> Mirador::Client#classify_file\r\n\r\nA shortcut for classifying a single file; this will return a `Mirador::Result` instead of a `Mirador::ResultList`:\r\n\r\n```ruby\r\nrequire 'mirador'\r\nmc = Mirador::Client.new 'your_api_key'\r\n\r\n# first method: use ids as keys\r\nnsfw = mc.classify_file(nsfw: 'nsfw.jpg')\r\n\r\nputs nsfw.value\r\n```\r\n\r\n### <a name='classify_buffers'></a> Mirador:Client#classify_buffers\r\n\r\nClassify a buffer, e.g., an already-read file. This simplifies the classification of file uploads, e.g. POST data. The interface is identical to [classify_files](#classify_files), only differing in the actual data passed in:\r\n\r\n```ruby\r\nrequire 'mirador'\r\nmc = Mirador::Client.new 'your_api_key'\r\n\r\nnsfw_buf = File.read('nsfw.jpg')\r\nsfw_buf = File.read('sfw.jpg')\r\n\r\n# these are equivalent\r\nresults = mc.classify_buffers(nsfw: nsfw_buf, sfw: sfw_buf)\r\nresults = mc.classify_buffers([{id: :nsfw, data: nsfw_buf}, {id: :sfw, data: sfw_buf}])\r\n\r\n# since buffers dont have a name, you just get an index as id\r\nresults = mc.classify_buffers(nsfw_buf, sfw_buf)\r\n```\r\n\r\n#### <a name='classify_buffer'></a> Mirador::Client#classify_buffer\r\n\r\nAs with classify_file, there is a shortcut for classifying only one buffer; see [classify_file](#classify_file) for clarifications on usage (it's identical).\r\n\r\n### <a name='classify_encoded_strings'></a> Mirador::Client#classify_encoded_strings\r\n\r\nThe Mirador API internally represents images as base64-encoded strings (agnostic of image encoding); this method lets you pass in an alread-encoded string in the event that you're also using base64 encoding elsewhere in your system. Usage is the same as [classify_buffers](#classify_buffers):\r\n\r\n```ruby\r\nrequire 'mirador'\r\nrequire 'base64'\r\n\r\nmc = Mirador::Client.new 'your_api_key'\r\n\r\nnsfw_buf = Base64.encode64(File.read('nsfw.jpg'))\r\nsfw_buf = Base64.encode64(File.read('sfw.jpg'))\r\n\r\n# these are equivalent\r\nresults = mc.classify_encoded_strings(nsfw: nsfw_buf, sfw: sfw_buf)\r\nresults = mc.classify_encoded_strings([{id: :nsfw, data: nsfw_buf}, {id: :sfw, data: sfw_buf}])\r\n\r\n# since strings dont have a name, you just get an index as id\r\nresults = mc.classify_encoded_strings(nsfw_buf, sfw_buf)\r\n```\r\n\r\n#### <a name='classify_encoded_string'></a> Mirador::Client#classify_encoded_string\r\n\r\nAnother helper for only working with 1 request/result at a time. See [classify_file](#classify_file) for more info.\r\n\r\n\r\n### <a name='classify_data_uris'></a> Mirador::Client#classify_data_uris\r\n\r\nThis simplifies data transfer between client applications and the mirador API. For example, given the following javascript:\r\n\r\n```javascript\r\ndocument.getElementById('form-field').addEventListener('change', function (e) {\r\n\r\n  var file = this.files[0];\r\n\r\n  var reader = new FileReader();\r\n  reader.onload = function (e) {\r\n    $.post('/proxy/mirador', { id: file.name, data: e.target.result });\r\n  }\r\n\r\n  reader.readAsDataURL(file);\r\n});\r\n```\r\n\r\nYour could classify that data url with the following code:\r\n\r\n```ruby\r\n\r\nres = mc.classify_data_uris(request['id'] => request['data'])\r\n\r\n# send the result\r\nres[request['id']].to_json\r\n\r\n# or, even easier\r\nmc.classify_data_uri(request['id'] => request['data']).to_json\r\n\r\n```\r\n\r\nOtherwise, classify_data_uris and classify_data_uri have identical interfaces to the other methods covered so far.\r\n\r\n\r\n## Classify URLs\r\n\r\nYou can easily classify a publically-available URL (e.g., a public s3 bucket), with [classify_urls](#classify_urls) and [classify_url](#classify_url). The interfaces for these methods are identical to the file-handling methods covered above.\r\n\r\n\r\n### <a name='classify_urls'></a> Mirador::Client#classify_urls\r\n\r\nThe only things to keep in mind with URLs:\r\n\r\n* must be publically-accessibly\r\n* must be < Mirador::Client::MAX_ID_LEN if you are using the url as the item's id (see below)\r\n* download/response time on url will affect response time of result, must be less than 60 seconds.\r\n\r\n\r\n#### Examples:\r\n\r\n\r\nAssigning specific ids to urls:\r\n\r\n```ruby\r\nrequire 'mirador'\r\n\r\nmc = Mirador::Client.new 'your_api_key'\r\n\r\nres = mc.classify_urls(nsfw: 'http://static.mirador.im/test/nsfw.jpg', sfw: 'http://static.mirador.im/test/sfw.jpg')\r\n\r\nassert res[:nsfw]\r\nassert res[:sfw].safe\r\n\r\n```\r\n\r\nImplicitly using url as its own id:\r\n\r\n```ruby\r\nrequire 'mirador'\r\n\r\nnsfw_url = 'http://static.mirador.im/test/nsfw.jpg'\r\nsfw_url = 'http://static.mirador.im/test/sfw.jpg'\r\n\r\nmc = Mirador::Client.new 'your_api_key'\r\nres = mc.classify_urls(nsfw_url, sfw_url)\r\n\r\nputs res[nsfw_url].value\r\nputs res[sfw_url].value\r\n```\r\n\r\nClassify a single URL using Mirador::Client#classify_url\r\n\r\n```ruby\r\nrequire 'mirador'\r\n\r\nmc = Mirador::Client.new 'your_api_key'\r\nnsfw = mc.classify_url(nsfw_url)\r\n\r\nassert (not nsfw.safe)\r\nputs nsfw.value\r\n```\r\n\r\n## <a name='result'></a> Mirador::Result\r\n\r\nThe `Mirador::Result` class wraps the output of the API for a specific image/url. It has the following attributes:\r\n\r\n* `@id` [Mixed]: the id, as specified in the request, or implied (see above)\r\n* `@safe` [Boolean]: whether the image should be considered flagged/containing adult content\r\n* `@value` [Float 0.0-1.0]: A float indicating the likelyhood of the image containing adult content (useful for creating custom thresholds)\r\n* `@error` [String]: will only be non-nil if this is an error\r\n\r\nThe `Mirador::Result` object also has a couple of convenience methods:\r\n\r\n* `#to_h` - convert to a hash\r\n* `#to_json` - if json is require'd, serialize to json\r\n* `#failed?` - returns a boolean indicating whether image is a failure/error\r\n* `#to_s` - returns a string representation of the result`\r\n* `#name` **(deprecated)** - this simply maps to `@id`\r\n\r\n## <a name='resultlist'></a> Mirador::ResultList [Enumerable]\r\n\r\nMethods that return multiple results do so by returning a single `Mirador::ResultList`. This object is used in lieu of a Hash or Array as to provide mixed-access. You can treat it as an array, iterating via `each do |x|`, indexing with integers, or by simply calling `#to_a`, or as a hash, indexing with `@id`'s from image-requests.\r\n\r\nThe ResultList has the following methods:\r\n\r\n* `#[](key)` operator override to index the ResultList. You can index by integers in range of 0 - ResultList#length, or by an `@id` for one of the Result objects within.\r\n* `#to_a` convert to an array of `Mirador::Result` objects\r\n* `#length` the number of items in the `ResultList`\r\n* `#update` equivalent to Hash#update\r\n* `#to_h` conver to a hash\r\n* `#to_json` serialize the resultlist as json\r\n* `#each` `ResultList` includes `Enumerable`, and this implementation of `#each` checks the arity of blocks passed in to allow iteration either as an array or as a Hash.\r\n\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n\r\n## Support\r\n\r\nPlease submit and bugs as issues, and don't hesitate to contact support@mirador.im with questions or issues.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}